package com.github.mmolimar.ksql.jdbc

import java.sql.{Connection, ResultSet, SQLWarning, Statement}

import com.github.mmolimar.ksql.jdbc.Exceptions._
import com.github.mmolimar.ksql.jdbc.resultset.KsqlResultSet
import io.confluent.ksql.rest.client.KsqlRestClient

class KsqlStatement(private val ksqlClient: KsqlRestClient) extends Statement with WrapperNotSupported {

  override def setMaxFieldSize(max: Int): Unit = throw NotSupported()

  override def getMoreResults: Boolean = throw NotSupported()

  override def getMoreResults(current: Int): Boolean = throw NotSupported()

  override def clearWarnings(): Unit = throw NotSupported()

  override def getGeneratedKeys: ResultSet = throw NotSupported()

  override def closeOnCompletion(): Unit = throw NotSupported()

  override def cancel(): Unit = throw NotSupported()

  override def getResultSet: ResultSet = throw NotSupported()

  override def isPoolable: Boolean = throw NotSupported()

  override def setPoolable(poolable: Boolean): Unit = throw NotSupported()

  override def setCursorName(name: String): Unit = throw NotSupported()

  override def getUpdateCount: Int = throw NotSupported()

  override def addBatch(sql: String): Unit = throw NotSupported()

  override def getMaxRows: Int = throw NotSupported()

  override def execute(sql: String): Boolean = ksqlClient.makeKsqlRequest(fixSql(sql)).isSuccessful

  //TODO
  override def execute(sql: String, autoGeneratedKeys: Int): Boolean = execute(sql)

  //TODO
  override def execute(sql: String, columnIndexes: Array[Int]): Boolean = execute(sql)

  //TODO
  override def execute(sql: String, columnNames: Array[String]): Boolean = execute(sql)

  override def executeQuery(sql: String): ResultSet = {
    val response = ksqlClient.makeQueryRequest(fixSql(sql))
    if (response.isErroneous)
      throw KsqlQueryError(s"Error executing query '${sql}'. " +
        s"Error: ${response.getErrorMessage.getMessage}")

    response.getResponse
  }

  override def getResultSetType: Int = throw NotSupported()

  override def setMaxRows(max: Int): Unit = throw NotSupported()

  override def getFetchSize: Int = throw NotSupported()

  override def getResultSetHoldability: Int = throw NotSupported()

  override def setFetchDirection(direction: Int): Unit = throw NotSupported()

  override def getFetchDirection: Int = throw NotSupported()

  override def getResultSetConcurrency: Int = throw NotSupported()

  override def clearBatch(): Unit = throw NotSupported()

  override def close(): Unit = throw NotSupported()

  override def isClosed: Boolean = throw NotSupported()

  override def executeUpdate(sql: String): Int = throw NotSupported()

  override def executeUpdate(sql: String, autoGeneratedKeys: Int): Int = throw NotSupported()

  override def executeUpdate(sql: String, columnIndexes: Array[Int]): Int = throw NotSupported()

  override def executeUpdate(sql: String, columnNames: Array[String]): Int = throw NotSupported()

  override def getQueryTimeout: Int = throw NotSupported()

  override def getWarnings: SQLWarning = throw NotSupported()

  override def setFetchSize(rows: Int): Unit = throw NotSupported()

  override def setQueryTimeout(seconds: Int): Unit = throw NotSupported()

  override def executeBatch(): Array[Int] = throw NotSupported()

  override def setEscapeProcessing(enable: Boolean): Unit = throw NotSupported()

  override def getConnection: Connection = throw NotSupported()

  override def getMaxFieldSize: Int = throw NotSupported()

  override def isCloseOnCompletion: Boolean = throw NotSupported()

  private def fixSql(sql: String) = if (sql.trim.endsWith(";")) sql else sql + ";"

  private implicit def toResultSet(stream: KsqlRestClient.QueryStream): ResultSet = new KsqlResultSet(stream)

}
